# Домашнее задание 1: TypeScript

## Формулировка задания

В качестве задания предлагается реализовать типы (легкие, средние и сложные). За каждый реализованный тип вы будете получать определенное количество баллов. Чем выше набранный балл, тем выше ваша оценка.

Задания низкой сложности (+0.5 балла за каждое задание)

1. `MyPick<T, K>` - `[key in K]` - это синтаксис mapped types в TypeScript, который проходит по каждому ключу из K и создает новый объект, содержащий только выбранные свойства. `T[key]` - берём значение типа для каждого ключа из оригинального типа `T`
2. `NOfArray<ArrayObj, N>` - стандартный синтаксис для доступа к элементу массива по индексу. Мы возвращаем тип элемента массива с индексом `N`
3. `Unshift<ArrayType, Element>` - `[Element, ...ArrayType[]]` - мы создаём новый массив, где первым элементом будет `Element`, а затем добавляются все элементы из оригинального массива `ArrayType[]`
4. `MyExclude<T, U>` - тип, который проверяет: если `T` является подтипом `U`, то возвращается never (элемент будет исключён), иначе вернется `T`

Задания средней сложности (+1 балл за каждое задание)

1. `DeepPartial <T>` -  `keyof T`: извлекает ключи объекта `T`. `T[key]`: это тип каждого значения, соответствующего ключу. Если значение является объектом (проверяется с помощью `extends object`), тип вызывает себя рекурсивно, чтобы сделать вложенные объекты также опциональными. В результате получается тип, где все поля объекта `T`, включая вложенные объекты, становятся опциональными.
2. `MyCapitalize<T>` - шаблонные литералы используются для разбиения строки на первую букву (`A`) и оставшуюся часть строки (`B`). `Uppercase<A>` преобразует первый символ в верхний регистр. Если строка не соответствует шаблону (например, пустая строка), возвращается оригинальная строка.
3. `DeepMutable<T>` - `-readonly` удаляет модификатор `readonly `с каждого ключа. Если значение является объектом, тип вызывает себя рекурсивно, чтобы сделать вложенные объекты тоже изменяемыми.
4. `ParseURLParams<StringElem>` - используются шаблонные литералы для разделения строки (`_` - заглушка, `Param `- параметр, `Other `- оставшаяся часть строки). Если строка содержит параметры (например, `"/:id/:user"`), извлекается каждый параметр (`id`, `user`) и объединяется через оператор `|`. Рекурсивно обрабатываются все сегменты строки, пока не будут извлечены все параметры.

Задания высокой сложности (+2 балла за каждое задание)

1. `Camelize<ObjectType>` - используя конструкцию `[key in keyof ObjectType]`, мы проходимся по каждому ключу объекта `ObjectType`. Далее, для каждого ключа тип применяет тип `CamelCase`, который преобразует строку из стиля snake_case в camelCase (подробнее об этом типе отдельно). `Extract<key, string>`: Используется для извлечения ключей только строкового типа. Это важно, поскольку ключи в TypeScript могут быть не только строками (например, символами), и нам нужно преобразовывать только строки. Рекурсия: если значение объекта является объектом (`Record<string, any>`), то вызывается тип `Camelize` рекурсивно для всех вложенных объектов. Если значение не является объектом, то просто возвращается его тип без изменений.
2. `CamelCase<S extends string>` - если строка содержит подчеркивание (`_`), то она делится на две части: `Left` (часть до подчеркивания) и `Right` (часть после подчеркивания). Правая часть (`Right`) рекурсивно преобразуется в camelCase, начиная с заглавной буквы. `Capitalize` применяется для того, чтобы сделать первую букву правой части строки заглавной.
3. `DeepPick<T, Paths>` - если `Paths` напрямую является ключом объекта `T`, то создается новый объект, содержащий только этот ключ и его значение: `{ [key in Paths]: T[key] }`. Если `Paths` представляет собой строку, содержащую точку (например, `"left.right"`), тип делит строку на две части: `Key` (часть до точки) и `B` (часть после точки). Если `Key` существует в объекте `T`, тип рекурсивно вызывает `DeepPick`, применяя его к вложенному объекту `T[Key]` и продолжая выборку по `B`. Процесс продолжается рекурсивно, пока не будут выбраны все вложенные поля, указанные в пути.

Также можно получить дополнительный балл за описание работы типа, если описание будет написано для всех типов, а также за удобство чтения кода.

При выполнении задания не запрещается редактировать исходный код слева от знаков присвоения.

Для выполнения задания допускается использование [официальной документации](https://typescriptlang.org), а также любых других источников, описывающих поведение типов. За использование ответов в открытом доступе (при нахождении таковых) вся работа аннулируется.

## Дедлайн

Сдача работы допускается в срок до 7 октября 2024г. 23:59:59. За каждый просроченный день итоговая оценка снижается на 1 балл.

## Порядок сдачи

Для сдачи работы на проверку необходимо склонировать задание в свой публичный репозиторий на github или gitlab, выполнить в нем задание скольким угодно числом коммитов и отправить ссылку на репозиторий в телеграм-канал "Домашние задания" с подписью <ФИО>_ДЗ-1. К проверке будет допущен последний выполененный коммит с рассчетом на просроченную сдачу.

Удачи в выполнении задания!
